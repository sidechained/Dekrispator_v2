This is a fork of the original Dekrispator project, where the original synth code has been swapped out for c code generated by [Faust](https://faust.grame.fr]).

# Usage Instructions

Write or copy some simple Faust code using the [Faust Online IDE](https://faustide.grame.fr). When complete, export the code using the truck icon using the following settings:

- File Name: 'mydsp'
- Platform 'source'
- Architecture 'c'

Click 'compile', then 'download', then copy the contents of the downloaded folder into the Synth directory of this repo.

Note: the code can have any name, but the filename must be added as an include statement in Synth/soundGen.c i.e

`#include "mydsp.c"`

Note: copied CInterface.h into Synth directory for now, which eliminates need to comment out 'meta' and 'ui' sections of mydsp.c code. More info [here](https://sourceforge.net/p/faudiostream/mailman/message/30907474/)

# UI -> MIDI UI

Faust code is typically developed using a simple onscreen User Interface with buttons/sliders etc. The aim is to swap out this interface for the existing MIDI control interface provided by Dekrispator.

In our case we are using the Korg NanoKontrol2 and have modified the original MIDI_Application.c/.h to create a simple Control Change (CC) and Note mapping for all NanoKontrol2 controls. These call functions which can be inserted into the Faust code, replacing the original user interface code elements.

## How are faust synth parameters actually controlled?

1. In mydsp.c, we need to add a function which will connect a synth interface to the places in memory where faust has already defined it's graphical ui_interface.

`
void buildEmbeddedUserInterfacemydsp(mydsp* dsp) {
      synth_interface.slider1 = &dsp->fHslider0;
      synth_interface.slider2 = &dsp->fHslider3;
      synth_interface.slider3 = &dsp->fHslider1;
      synth_interface.slider4 = &dsp->fHslider2;
}
`

2. In soundGen.c, we have already created a struct which will be used to interface with these existing values

`
typedef struct struct_synth_interface {
    float* slider1;
    float* slider2;
    float* slider3;
    float* slider4;
} synth_interface_t;

synth_interface_t synth_interface;
`

3. Then - also in soundGen.c - when intialising the synth we add a call to the 'buildEmbeddedUserInterfacemydsp' function. We also set some parameters to initial values here.

 Note that all parameters are scaled as in the original code (i.e. freq's operate from 50-10000, not as 0. - 1. floats). Which means we have to roll our own scaling when hooking up to the MIDI interface

`
void Synth_Init(void) {
    dsp = newmydsp();
    initmydsp(dsp, SAMPLERATE);
    buildEmbeddedUserInterfacemydsp(dsp);
    *(synth_interface.slider1) = 10000; // "[0]cutoffFrequencyL",500,50,10000,0.01    
    *(synth_interface.slider2) = 10000; // "[1]cutoffFrequencyR",500,50,10000,0.01
    *(synth_interface.slider3) = 1; // "[2]q",5,1,30,0.1);
    *(synth_interface.slider3) = 1; // "[3]gain",1,0,1,0.01); 
}
`

## Adding MIDI Control

- Now we need to allow access to the synth interface from our MIDI_Application.c code, as follows:

1. In soundGen.c, add four functions to allow outside access to the synth interface (not forgetting to also add their prototypes to soundGen.h)

`
void set_filter_cutoffFreqL(int val) {
    float floval;
    floval = ((float)val/127) * 9950 + 50;
    *(synth_interface.slider1) = floval; // "[0]cutoffFrequencyL",500,50,10000,0.01   
}

void set_filter_cutoffFreqR(int val) {
    float floval;
    floval = ((float)val/127) * 9950 + 50;
    *(synth_interface.slider2) = floval; // "[1]cutoffFrequencyR",500,50,10000,0.01  
}

void set_filter_q(int val) {
    float floval;
    floval = ((float)val/127) * 29 + 1;
    *(synth_interface.slider3) = floval; // "[2]q",5,1,30,0.1);  
}

void set_filter_gain(int val) {
    float floval;
    floval = (float)val/127;
    *(synth_interface.slider4) = floval; // "[3]gain",1,0,1,0.01);    
}
`

- Note that MIDI CC values come in as integers in the 0-127 range. Each function above handles the scaling necessary to get from this range to the range we require i.e. in the case of a filter cutoff frequency between 50-10000Hz

2. Now in MIDI_Application.c, we add calls to the above functions from whichever control we would like to affect that parameter (in our case NanoKontrol2 faders 1-4).

`
// FADERS 1-8
case 0:
      set_filter_cutoffFreqL(val);
      break;
case 1:
      set_filter_cutoffFreqR(val);
      break;
case 2:
      set_filter_q(val);
      break;
case 3:
      set_filter_gain(val);
      break;
`

# Further Aims:

- Make into an official architecture file

- Make drivers for MEMs microphone, accellerometer/tilt sensors
- Q: do these have to use HAL library to work well with Dekrispator?

STM32F4-Discovery_FW_V1.1.0/Project/Demonstration
Uses both the microphone and accelerometers
Performs a series of tests
      
      Accelerometer_MEMS_Test();
      Move discovery kit to detect negative and positive acceleration values on X, Y and Z axis
      
      USB_Test();
      USB Hardware connection

      Audio_Test();
      Audio Hardware connection

      
      Microphone_MEMS_Test();
      Microphone MEMS Hardware connection

Main functions are in selftest.c
Microphone uses I2S over SPI2
Q: Which library are these demos using? StdPer or HAL? A: StdPer
Dekrispator uses HAL
So best to find separate examples
Also need to be careful of peripheral conflicts (i.e. I2S for recording and playback)
Best would be to find a simultaneous audio record/playback example using HAL
STM32CubeF4 projects are good candidates, particularly this audio one here:
https://github.com/nguyenvuhung/STM32Cube_FW_F4/tree/master/Projects/STM32F4-Discovery/Applications/Audio/Audio_playback_and_record


## MEMs Microphone
ST-MEMS audio sensor omni-directional digital microphone
Vocoder project: https://github.com/Shaylin/stm32f4-discovery-vocoder (StdPeripheral Lib)

Also this demo, record to USB from microphone, playback (not simultaneously) (StdPeripheral Lib)
https://www.st.com/resource/en/application_note/an3997-audio-playback-and-recording-using-the-stm32f4discovery-stmicroelectronics.pdf
STM32F4-Discovery_FW_V1.1.0/Project/Audio_playback_and_record

## MEMS Accelerometer (LIS302DL)
ST MEMS 3-axis accelerometer



STM32F4-Discovery_FW_V1.1.0/Project/Peripheral_Examples/MEMS  (StdPeripheral Lib)
If the board is moved the acceleration is detected on x/Y axis and LEDs toggles according to the motion direction and speed


./STM32F4-Discovery_FW_V1.1.0/Utilities/STM32F4-Discovery/stm32f4_discovery_lis302dl.c

# Notes:

- confirmed that Stereo works
- output seems a bit 'crispy'
- strange clicks and pops within first few seconds of running